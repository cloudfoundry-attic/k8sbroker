// Code generated by counterfeiter. DO NOT EDIT.
package k8sbroker_fake

import (
	"sync"

	"code.cloudfoundry.org/k8sbroker/k8sbroker"
	v1core "k8s.io/client-go/kubernetes/typed/core/v1"
	"k8s.io/client-go/rest"
)

type FakeK8sCoreV1 struct {
	RESTClientStub        func() rest.Interface
	rESTClientMutex       sync.RWMutex
	rESTClientArgsForCall []struct{}
	rESTClientReturns     struct {
		result1 rest.Interface
	}
	rESTClientReturnsOnCall map[int]struct {
		result1 rest.Interface
	}
	ComponentStatusesStub        func() v1core.ComponentStatusInterface
	componentStatusesMutex       sync.RWMutex
	componentStatusesArgsForCall []struct{}
	componentStatusesReturns     struct {
		result1 v1core.ComponentStatusInterface
	}
	componentStatusesReturnsOnCall map[int]struct {
		result1 v1core.ComponentStatusInterface
	}
	ConfigMapsStub        func(namespace string) v1core.ConfigMapInterface
	configMapsMutex       sync.RWMutex
	configMapsArgsForCall []struct {
		namespace string
	}
	configMapsReturns struct {
		result1 v1core.ConfigMapInterface
	}
	configMapsReturnsOnCall map[int]struct {
		result1 v1core.ConfigMapInterface
	}
	EndpointsStub        func(namespace string) v1core.EndpointsInterface
	endpointsMutex       sync.RWMutex
	endpointsArgsForCall []struct {
		namespace string
	}
	endpointsReturns struct {
		result1 v1core.EndpointsInterface
	}
	endpointsReturnsOnCall map[int]struct {
		result1 v1core.EndpointsInterface
	}
	EventsStub        func(namespace string) v1core.EventInterface
	eventsMutex       sync.RWMutex
	eventsArgsForCall []struct {
		namespace string
	}
	eventsReturns struct {
		result1 v1core.EventInterface
	}
	eventsReturnsOnCall map[int]struct {
		result1 v1core.EventInterface
	}
	LimitRangesStub        func(namespace string) v1core.LimitRangeInterface
	limitRangesMutex       sync.RWMutex
	limitRangesArgsForCall []struct {
		namespace string
	}
	limitRangesReturns struct {
		result1 v1core.LimitRangeInterface
	}
	limitRangesReturnsOnCall map[int]struct {
		result1 v1core.LimitRangeInterface
	}
	NamespacesStub        func() v1core.NamespaceInterface
	namespacesMutex       sync.RWMutex
	namespacesArgsForCall []struct{}
	namespacesReturns     struct {
		result1 v1core.NamespaceInterface
	}
	namespacesReturnsOnCall map[int]struct {
		result1 v1core.NamespaceInterface
	}
	NodesStub        func() v1core.NodeInterface
	nodesMutex       sync.RWMutex
	nodesArgsForCall []struct{}
	nodesReturns     struct {
		result1 v1core.NodeInterface
	}
	nodesReturnsOnCall map[int]struct {
		result1 v1core.NodeInterface
	}
	PersistentVolumesStub        func() v1core.PersistentVolumeInterface
	persistentVolumesMutex       sync.RWMutex
	persistentVolumesArgsForCall []struct{}
	persistentVolumesReturns     struct {
		result1 v1core.PersistentVolumeInterface
	}
	persistentVolumesReturnsOnCall map[int]struct {
		result1 v1core.PersistentVolumeInterface
	}
	PersistentVolumeClaimsStub        func(namespace string) v1core.PersistentVolumeClaimInterface
	persistentVolumeClaimsMutex       sync.RWMutex
	persistentVolumeClaimsArgsForCall []struct {
		namespace string
	}
	persistentVolumeClaimsReturns struct {
		result1 v1core.PersistentVolumeClaimInterface
	}
	persistentVolumeClaimsReturnsOnCall map[int]struct {
		result1 v1core.PersistentVolumeClaimInterface
	}
	PodsStub        func(namespace string) v1core.PodInterface
	podsMutex       sync.RWMutex
	podsArgsForCall []struct {
		namespace string
	}
	podsReturns struct {
		result1 v1core.PodInterface
	}
	podsReturnsOnCall map[int]struct {
		result1 v1core.PodInterface
	}
	PodTemplatesStub        func(namespace string) v1core.PodTemplateInterface
	podTemplatesMutex       sync.RWMutex
	podTemplatesArgsForCall []struct {
		namespace string
	}
	podTemplatesReturns struct {
		result1 v1core.PodTemplateInterface
	}
	podTemplatesReturnsOnCall map[int]struct {
		result1 v1core.PodTemplateInterface
	}
	ReplicationControllersStub        func(namespace string) v1core.ReplicationControllerInterface
	replicationControllersMutex       sync.RWMutex
	replicationControllersArgsForCall []struct {
		namespace string
	}
	replicationControllersReturns struct {
		result1 v1core.ReplicationControllerInterface
	}
	replicationControllersReturnsOnCall map[int]struct {
		result1 v1core.ReplicationControllerInterface
	}
	ResourceQuotasStub        func(namespace string) v1core.ResourceQuotaInterface
	resourceQuotasMutex       sync.RWMutex
	resourceQuotasArgsForCall []struct {
		namespace string
	}
	resourceQuotasReturns struct {
		result1 v1core.ResourceQuotaInterface
	}
	resourceQuotasReturnsOnCall map[int]struct {
		result1 v1core.ResourceQuotaInterface
	}
	SecretsStub        func(namespace string) v1core.SecretInterface
	secretsMutex       sync.RWMutex
	secretsArgsForCall []struct {
		namespace string
	}
	secretsReturns struct {
		result1 v1core.SecretInterface
	}
	secretsReturnsOnCall map[int]struct {
		result1 v1core.SecretInterface
	}
	ServicesStub        func(namespace string) v1core.ServiceInterface
	servicesMutex       sync.RWMutex
	servicesArgsForCall []struct {
		namespace string
	}
	servicesReturns struct {
		result1 v1core.ServiceInterface
	}
	servicesReturnsOnCall map[int]struct {
		result1 v1core.ServiceInterface
	}
	ServiceAccountsStub        func(namespace string) v1core.ServiceAccountInterface
	serviceAccountsMutex       sync.RWMutex
	serviceAccountsArgsForCall []struct {
		namespace string
	}
	serviceAccountsReturns struct {
		result1 v1core.ServiceAccountInterface
	}
	serviceAccountsReturnsOnCall map[int]struct {
		result1 v1core.ServiceAccountInterface
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeK8sCoreV1) RESTClient() rest.Interface {
	fake.rESTClientMutex.Lock()
	ret, specificReturn := fake.rESTClientReturnsOnCall[len(fake.rESTClientArgsForCall)]
	fake.rESTClientArgsForCall = append(fake.rESTClientArgsForCall, struct{}{})
	fake.recordInvocation("RESTClient", []interface{}{})
	fake.rESTClientMutex.Unlock()
	if fake.RESTClientStub != nil {
		return fake.RESTClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rESTClientReturns.result1
}

func (fake *FakeK8sCoreV1) RESTClientCallCount() int {
	fake.rESTClientMutex.RLock()
	defer fake.rESTClientMutex.RUnlock()
	return len(fake.rESTClientArgsForCall)
}

func (fake *FakeK8sCoreV1) RESTClientReturns(result1 rest.Interface) {
	fake.RESTClientStub = nil
	fake.rESTClientReturns = struct {
		result1 rest.Interface
	}{result1}
}

func (fake *FakeK8sCoreV1) RESTClientReturnsOnCall(i int, result1 rest.Interface) {
	fake.RESTClientStub = nil
	if fake.rESTClientReturnsOnCall == nil {
		fake.rESTClientReturnsOnCall = make(map[int]struct {
			result1 rest.Interface
		})
	}
	fake.rESTClientReturnsOnCall[i] = struct {
		result1 rest.Interface
	}{result1}
}

func (fake *FakeK8sCoreV1) ComponentStatuses() v1core.ComponentStatusInterface {
	fake.componentStatusesMutex.Lock()
	ret, specificReturn := fake.componentStatusesReturnsOnCall[len(fake.componentStatusesArgsForCall)]
	fake.componentStatusesArgsForCall = append(fake.componentStatusesArgsForCall, struct{}{})
	fake.recordInvocation("ComponentStatuses", []interface{}{})
	fake.componentStatusesMutex.Unlock()
	if fake.ComponentStatusesStub != nil {
		return fake.ComponentStatusesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.componentStatusesReturns.result1
}

func (fake *FakeK8sCoreV1) ComponentStatusesCallCount() int {
	fake.componentStatusesMutex.RLock()
	defer fake.componentStatusesMutex.RUnlock()
	return len(fake.componentStatusesArgsForCall)
}

func (fake *FakeK8sCoreV1) ComponentStatusesReturns(result1 v1core.ComponentStatusInterface) {
	fake.ComponentStatusesStub = nil
	fake.componentStatusesReturns = struct {
		result1 v1core.ComponentStatusInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ComponentStatusesReturnsOnCall(i int, result1 v1core.ComponentStatusInterface) {
	fake.ComponentStatusesStub = nil
	if fake.componentStatusesReturnsOnCall == nil {
		fake.componentStatusesReturnsOnCall = make(map[int]struct {
			result1 v1core.ComponentStatusInterface
		})
	}
	fake.componentStatusesReturnsOnCall[i] = struct {
		result1 v1core.ComponentStatusInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ConfigMaps(namespace string) v1core.ConfigMapInterface {
	fake.configMapsMutex.Lock()
	ret, specificReturn := fake.configMapsReturnsOnCall[len(fake.configMapsArgsForCall)]
	fake.configMapsArgsForCall = append(fake.configMapsArgsForCall, struct {
		namespace string
	}{namespace})
	fake.recordInvocation("ConfigMaps", []interface{}{namespace})
	fake.configMapsMutex.Unlock()
	if fake.ConfigMapsStub != nil {
		return fake.ConfigMapsStub(namespace)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.configMapsReturns.result1
}

func (fake *FakeK8sCoreV1) ConfigMapsCallCount() int {
	fake.configMapsMutex.RLock()
	defer fake.configMapsMutex.RUnlock()
	return len(fake.configMapsArgsForCall)
}

func (fake *FakeK8sCoreV1) ConfigMapsArgsForCall(i int) string {
	fake.configMapsMutex.RLock()
	defer fake.configMapsMutex.RUnlock()
	return fake.configMapsArgsForCall[i].namespace
}

func (fake *FakeK8sCoreV1) ConfigMapsReturns(result1 v1core.ConfigMapInterface) {
	fake.ConfigMapsStub = nil
	fake.configMapsReturns = struct {
		result1 v1core.ConfigMapInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ConfigMapsReturnsOnCall(i int, result1 v1core.ConfigMapInterface) {
	fake.ConfigMapsStub = nil
	if fake.configMapsReturnsOnCall == nil {
		fake.configMapsReturnsOnCall = make(map[int]struct {
			result1 v1core.ConfigMapInterface
		})
	}
	fake.configMapsReturnsOnCall[i] = struct {
		result1 v1core.ConfigMapInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Endpoints(namespace string) v1core.EndpointsInterface {
	fake.endpointsMutex.Lock()
	ret, specificReturn := fake.endpointsReturnsOnCall[len(fake.endpointsArgsForCall)]
	fake.endpointsArgsForCall = append(fake.endpointsArgsForCall, struct {
		namespace string
	}{namespace})
	fake.recordInvocation("Endpoints", []interface{}{namespace})
	fake.endpointsMutex.Unlock()
	if fake.EndpointsStub != nil {
		return fake.EndpointsStub(namespace)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.endpointsReturns.result1
}

func (fake *FakeK8sCoreV1) EndpointsCallCount() int {
	fake.endpointsMutex.RLock()
	defer fake.endpointsMutex.RUnlock()
	return len(fake.endpointsArgsForCall)
}

func (fake *FakeK8sCoreV1) EndpointsArgsForCall(i int) string {
	fake.endpointsMutex.RLock()
	defer fake.endpointsMutex.RUnlock()
	return fake.endpointsArgsForCall[i].namespace
}

func (fake *FakeK8sCoreV1) EndpointsReturns(result1 v1core.EndpointsInterface) {
	fake.EndpointsStub = nil
	fake.endpointsReturns = struct {
		result1 v1core.EndpointsInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) EndpointsReturnsOnCall(i int, result1 v1core.EndpointsInterface) {
	fake.EndpointsStub = nil
	if fake.endpointsReturnsOnCall == nil {
		fake.endpointsReturnsOnCall = make(map[int]struct {
			result1 v1core.EndpointsInterface
		})
	}
	fake.endpointsReturnsOnCall[i] = struct {
		result1 v1core.EndpointsInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Events(namespace string) v1core.EventInterface {
	fake.eventsMutex.Lock()
	ret, specificReturn := fake.eventsReturnsOnCall[len(fake.eventsArgsForCall)]
	fake.eventsArgsForCall = append(fake.eventsArgsForCall, struct {
		namespace string
	}{namespace})
	fake.recordInvocation("Events", []interface{}{namespace})
	fake.eventsMutex.Unlock()
	if fake.EventsStub != nil {
		return fake.EventsStub(namespace)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.eventsReturns.result1
}

func (fake *FakeK8sCoreV1) EventsCallCount() int {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return len(fake.eventsArgsForCall)
}

func (fake *FakeK8sCoreV1) EventsArgsForCall(i int) string {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return fake.eventsArgsForCall[i].namespace
}

func (fake *FakeK8sCoreV1) EventsReturns(result1 v1core.EventInterface) {
	fake.EventsStub = nil
	fake.eventsReturns = struct {
		result1 v1core.EventInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) EventsReturnsOnCall(i int, result1 v1core.EventInterface) {
	fake.EventsStub = nil
	if fake.eventsReturnsOnCall == nil {
		fake.eventsReturnsOnCall = make(map[int]struct {
			result1 v1core.EventInterface
		})
	}
	fake.eventsReturnsOnCall[i] = struct {
		result1 v1core.EventInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) LimitRanges(namespace string) v1core.LimitRangeInterface {
	fake.limitRangesMutex.Lock()
	ret, specificReturn := fake.limitRangesReturnsOnCall[len(fake.limitRangesArgsForCall)]
	fake.limitRangesArgsForCall = append(fake.limitRangesArgsForCall, struct {
		namespace string
	}{namespace})
	fake.recordInvocation("LimitRanges", []interface{}{namespace})
	fake.limitRangesMutex.Unlock()
	if fake.LimitRangesStub != nil {
		return fake.LimitRangesStub(namespace)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.limitRangesReturns.result1
}

func (fake *FakeK8sCoreV1) LimitRangesCallCount() int {
	fake.limitRangesMutex.RLock()
	defer fake.limitRangesMutex.RUnlock()
	return len(fake.limitRangesArgsForCall)
}

func (fake *FakeK8sCoreV1) LimitRangesArgsForCall(i int) string {
	fake.limitRangesMutex.RLock()
	defer fake.limitRangesMutex.RUnlock()
	return fake.limitRangesArgsForCall[i].namespace
}

func (fake *FakeK8sCoreV1) LimitRangesReturns(result1 v1core.LimitRangeInterface) {
	fake.LimitRangesStub = nil
	fake.limitRangesReturns = struct {
		result1 v1core.LimitRangeInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) LimitRangesReturnsOnCall(i int, result1 v1core.LimitRangeInterface) {
	fake.LimitRangesStub = nil
	if fake.limitRangesReturnsOnCall == nil {
		fake.limitRangesReturnsOnCall = make(map[int]struct {
			result1 v1core.LimitRangeInterface
		})
	}
	fake.limitRangesReturnsOnCall[i] = struct {
		result1 v1core.LimitRangeInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Namespaces() v1core.NamespaceInterface {
	fake.namespacesMutex.Lock()
	ret, specificReturn := fake.namespacesReturnsOnCall[len(fake.namespacesArgsForCall)]
	fake.namespacesArgsForCall = append(fake.namespacesArgsForCall, struct{}{})
	fake.recordInvocation("Namespaces", []interface{}{})
	fake.namespacesMutex.Unlock()
	if fake.NamespacesStub != nil {
		return fake.NamespacesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.namespacesReturns.result1
}

func (fake *FakeK8sCoreV1) NamespacesCallCount() int {
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	return len(fake.namespacesArgsForCall)
}

func (fake *FakeK8sCoreV1) NamespacesReturns(result1 v1core.NamespaceInterface) {
	fake.NamespacesStub = nil
	fake.namespacesReturns = struct {
		result1 v1core.NamespaceInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) NamespacesReturnsOnCall(i int, result1 v1core.NamespaceInterface) {
	fake.NamespacesStub = nil
	if fake.namespacesReturnsOnCall == nil {
		fake.namespacesReturnsOnCall = make(map[int]struct {
			result1 v1core.NamespaceInterface
		})
	}
	fake.namespacesReturnsOnCall[i] = struct {
		result1 v1core.NamespaceInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Nodes() v1core.NodeInterface {
	fake.nodesMutex.Lock()
	ret, specificReturn := fake.nodesReturnsOnCall[len(fake.nodesArgsForCall)]
	fake.nodesArgsForCall = append(fake.nodesArgsForCall, struct{}{})
	fake.recordInvocation("Nodes", []interface{}{})
	fake.nodesMutex.Unlock()
	if fake.NodesStub != nil {
		return fake.NodesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nodesReturns.result1
}

func (fake *FakeK8sCoreV1) NodesCallCount() int {
	fake.nodesMutex.RLock()
	defer fake.nodesMutex.RUnlock()
	return len(fake.nodesArgsForCall)
}

func (fake *FakeK8sCoreV1) NodesReturns(result1 v1core.NodeInterface) {
	fake.NodesStub = nil
	fake.nodesReturns = struct {
		result1 v1core.NodeInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) NodesReturnsOnCall(i int, result1 v1core.NodeInterface) {
	fake.NodesStub = nil
	if fake.nodesReturnsOnCall == nil {
		fake.nodesReturnsOnCall = make(map[int]struct {
			result1 v1core.NodeInterface
		})
	}
	fake.nodesReturnsOnCall[i] = struct {
		result1 v1core.NodeInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) PersistentVolumes() v1core.PersistentVolumeInterface {
	fake.persistentVolumesMutex.Lock()
	ret, specificReturn := fake.persistentVolumesReturnsOnCall[len(fake.persistentVolumesArgsForCall)]
	fake.persistentVolumesArgsForCall = append(fake.persistentVolumesArgsForCall, struct{}{})
	fake.recordInvocation("PersistentVolumes", []interface{}{})
	fake.persistentVolumesMutex.Unlock()
	if fake.PersistentVolumesStub != nil {
		return fake.PersistentVolumesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.persistentVolumesReturns.result1
}

func (fake *FakeK8sCoreV1) PersistentVolumesCallCount() int {
	fake.persistentVolumesMutex.RLock()
	defer fake.persistentVolumesMutex.RUnlock()
	return len(fake.persistentVolumesArgsForCall)
}

func (fake *FakeK8sCoreV1) PersistentVolumesReturns(result1 v1core.PersistentVolumeInterface) {
	fake.PersistentVolumesStub = nil
	fake.persistentVolumesReturns = struct {
		result1 v1core.PersistentVolumeInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) PersistentVolumesReturnsOnCall(i int, result1 v1core.PersistentVolumeInterface) {
	fake.PersistentVolumesStub = nil
	if fake.persistentVolumesReturnsOnCall == nil {
		fake.persistentVolumesReturnsOnCall = make(map[int]struct {
			result1 v1core.PersistentVolumeInterface
		})
	}
	fake.persistentVolumesReturnsOnCall[i] = struct {
		result1 v1core.PersistentVolumeInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) PersistentVolumeClaims(namespace string) v1core.PersistentVolumeClaimInterface {
	fake.persistentVolumeClaimsMutex.Lock()
	ret, specificReturn := fake.persistentVolumeClaimsReturnsOnCall[len(fake.persistentVolumeClaimsArgsForCall)]
	fake.persistentVolumeClaimsArgsForCall = append(fake.persistentVolumeClaimsArgsForCall, struct {
		namespace string
	}{namespace})
	fake.recordInvocation("PersistentVolumeClaims", []interface{}{namespace})
	fake.persistentVolumeClaimsMutex.Unlock()
	if fake.PersistentVolumeClaimsStub != nil {
		return fake.PersistentVolumeClaimsStub(namespace)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.persistentVolumeClaimsReturns.result1
}

func (fake *FakeK8sCoreV1) PersistentVolumeClaimsCallCount() int {
	fake.persistentVolumeClaimsMutex.RLock()
	defer fake.persistentVolumeClaimsMutex.RUnlock()
	return len(fake.persistentVolumeClaimsArgsForCall)
}

func (fake *FakeK8sCoreV1) PersistentVolumeClaimsArgsForCall(i int) string {
	fake.persistentVolumeClaimsMutex.RLock()
	defer fake.persistentVolumeClaimsMutex.RUnlock()
	return fake.persistentVolumeClaimsArgsForCall[i].namespace
}

func (fake *FakeK8sCoreV1) PersistentVolumeClaimsReturns(result1 v1core.PersistentVolumeClaimInterface) {
	fake.PersistentVolumeClaimsStub = nil
	fake.persistentVolumeClaimsReturns = struct {
		result1 v1core.PersistentVolumeClaimInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) PersistentVolumeClaimsReturnsOnCall(i int, result1 v1core.PersistentVolumeClaimInterface) {
	fake.PersistentVolumeClaimsStub = nil
	if fake.persistentVolumeClaimsReturnsOnCall == nil {
		fake.persistentVolumeClaimsReturnsOnCall = make(map[int]struct {
			result1 v1core.PersistentVolumeClaimInterface
		})
	}
	fake.persistentVolumeClaimsReturnsOnCall[i] = struct {
		result1 v1core.PersistentVolumeClaimInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Pods(namespace string) v1core.PodInterface {
	fake.podsMutex.Lock()
	ret, specificReturn := fake.podsReturnsOnCall[len(fake.podsArgsForCall)]
	fake.podsArgsForCall = append(fake.podsArgsForCall, struct {
		namespace string
	}{namespace})
	fake.recordInvocation("Pods", []interface{}{namespace})
	fake.podsMutex.Unlock()
	if fake.PodsStub != nil {
		return fake.PodsStub(namespace)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.podsReturns.result1
}

func (fake *FakeK8sCoreV1) PodsCallCount() int {
	fake.podsMutex.RLock()
	defer fake.podsMutex.RUnlock()
	return len(fake.podsArgsForCall)
}

func (fake *FakeK8sCoreV1) PodsArgsForCall(i int) string {
	fake.podsMutex.RLock()
	defer fake.podsMutex.RUnlock()
	return fake.podsArgsForCall[i].namespace
}

func (fake *FakeK8sCoreV1) PodsReturns(result1 v1core.PodInterface) {
	fake.PodsStub = nil
	fake.podsReturns = struct {
		result1 v1core.PodInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) PodsReturnsOnCall(i int, result1 v1core.PodInterface) {
	fake.PodsStub = nil
	if fake.podsReturnsOnCall == nil {
		fake.podsReturnsOnCall = make(map[int]struct {
			result1 v1core.PodInterface
		})
	}
	fake.podsReturnsOnCall[i] = struct {
		result1 v1core.PodInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) PodTemplates(namespace string) v1core.PodTemplateInterface {
	fake.podTemplatesMutex.Lock()
	ret, specificReturn := fake.podTemplatesReturnsOnCall[len(fake.podTemplatesArgsForCall)]
	fake.podTemplatesArgsForCall = append(fake.podTemplatesArgsForCall, struct {
		namespace string
	}{namespace})
	fake.recordInvocation("PodTemplates", []interface{}{namespace})
	fake.podTemplatesMutex.Unlock()
	if fake.PodTemplatesStub != nil {
		return fake.PodTemplatesStub(namespace)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.podTemplatesReturns.result1
}

func (fake *FakeK8sCoreV1) PodTemplatesCallCount() int {
	fake.podTemplatesMutex.RLock()
	defer fake.podTemplatesMutex.RUnlock()
	return len(fake.podTemplatesArgsForCall)
}

func (fake *FakeK8sCoreV1) PodTemplatesArgsForCall(i int) string {
	fake.podTemplatesMutex.RLock()
	defer fake.podTemplatesMutex.RUnlock()
	return fake.podTemplatesArgsForCall[i].namespace
}

func (fake *FakeK8sCoreV1) PodTemplatesReturns(result1 v1core.PodTemplateInterface) {
	fake.PodTemplatesStub = nil
	fake.podTemplatesReturns = struct {
		result1 v1core.PodTemplateInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) PodTemplatesReturnsOnCall(i int, result1 v1core.PodTemplateInterface) {
	fake.PodTemplatesStub = nil
	if fake.podTemplatesReturnsOnCall == nil {
		fake.podTemplatesReturnsOnCall = make(map[int]struct {
			result1 v1core.PodTemplateInterface
		})
	}
	fake.podTemplatesReturnsOnCall[i] = struct {
		result1 v1core.PodTemplateInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ReplicationControllers(namespace string) v1core.ReplicationControllerInterface {
	fake.replicationControllersMutex.Lock()
	ret, specificReturn := fake.replicationControllersReturnsOnCall[len(fake.replicationControllersArgsForCall)]
	fake.replicationControllersArgsForCall = append(fake.replicationControllersArgsForCall, struct {
		namespace string
	}{namespace})
	fake.recordInvocation("ReplicationControllers", []interface{}{namespace})
	fake.replicationControllersMutex.Unlock()
	if fake.ReplicationControllersStub != nil {
		return fake.ReplicationControllersStub(namespace)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.replicationControllersReturns.result1
}

func (fake *FakeK8sCoreV1) ReplicationControllersCallCount() int {
	fake.replicationControllersMutex.RLock()
	defer fake.replicationControllersMutex.RUnlock()
	return len(fake.replicationControllersArgsForCall)
}

func (fake *FakeK8sCoreV1) ReplicationControllersArgsForCall(i int) string {
	fake.replicationControllersMutex.RLock()
	defer fake.replicationControllersMutex.RUnlock()
	return fake.replicationControllersArgsForCall[i].namespace
}

func (fake *FakeK8sCoreV1) ReplicationControllersReturns(result1 v1core.ReplicationControllerInterface) {
	fake.ReplicationControllersStub = nil
	fake.replicationControllersReturns = struct {
		result1 v1core.ReplicationControllerInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ReplicationControllersReturnsOnCall(i int, result1 v1core.ReplicationControllerInterface) {
	fake.ReplicationControllersStub = nil
	if fake.replicationControllersReturnsOnCall == nil {
		fake.replicationControllersReturnsOnCall = make(map[int]struct {
			result1 v1core.ReplicationControllerInterface
		})
	}
	fake.replicationControllersReturnsOnCall[i] = struct {
		result1 v1core.ReplicationControllerInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ResourceQuotas(namespace string) v1core.ResourceQuotaInterface {
	fake.resourceQuotasMutex.Lock()
	ret, specificReturn := fake.resourceQuotasReturnsOnCall[len(fake.resourceQuotasArgsForCall)]
	fake.resourceQuotasArgsForCall = append(fake.resourceQuotasArgsForCall, struct {
		namespace string
	}{namespace})
	fake.recordInvocation("ResourceQuotas", []interface{}{namespace})
	fake.resourceQuotasMutex.Unlock()
	if fake.ResourceQuotasStub != nil {
		return fake.ResourceQuotasStub(namespace)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.resourceQuotasReturns.result1
}

func (fake *FakeK8sCoreV1) ResourceQuotasCallCount() int {
	fake.resourceQuotasMutex.RLock()
	defer fake.resourceQuotasMutex.RUnlock()
	return len(fake.resourceQuotasArgsForCall)
}

func (fake *FakeK8sCoreV1) ResourceQuotasArgsForCall(i int) string {
	fake.resourceQuotasMutex.RLock()
	defer fake.resourceQuotasMutex.RUnlock()
	return fake.resourceQuotasArgsForCall[i].namespace
}

func (fake *FakeK8sCoreV1) ResourceQuotasReturns(result1 v1core.ResourceQuotaInterface) {
	fake.ResourceQuotasStub = nil
	fake.resourceQuotasReturns = struct {
		result1 v1core.ResourceQuotaInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ResourceQuotasReturnsOnCall(i int, result1 v1core.ResourceQuotaInterface) {
	fake.ResourceQuotasStub = nil
	if fake.resourceQuotasReturnsOnCall == nil {
		fake.resourceQuotasReturnsOnCall = make(map[int]struct {
			result1 v1core.ResourceQuotaInterface
		})
	}
	fake.resourceQuotasReturnsOnCall[i] = struct {
		result1 v1core.ResourceQuotaInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Secrets(namespace string) v1core.SecretInterface {
	fake.secretsMutex.Lock()
	ret, specificReturn := fake.secretsReturnsOnCall[len(fake.secretsArgsForCall)]
	fake.secretsArgsForCall = append(fake.secretsArgsForCall, struct {
		namespace string
	}{namespace})
	fake.recordInvocation("Secrets", []interface{}{namespace})
	fake.secretsMutex.Unlock()
	if fake.SecretsStub != nil {
		return fake.SecretsStub(namespace)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.secretsReturns.result1
}

func (fake *FakeK8sCoreV1) SecretsCallCount() int {
	fake.secretsMutex.RLock()
	defer fake.secretsMutex.RUnlock()
	return len(fake.secretsArgsForCall)
}

func (fake *FakeK8sCoreV1) SecretsArgsForCall(i int) string {
	fake.secretsMutex.RLock()
	defer fake.secretsMutex.RUnlock()
	return fake.secretsArgsForCall[i].namespace
}

func (fake *FakeK8sCoreV1) SecretsReturns(result1 v1core.SecretInterface) {
	fake.SecretsStub = nil
	fake.secretsReturns = struct {
		result1 v1core.SecretInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) SecretsReturnsOnCall(i int, result1 v1core.SecretInterface) {
	fake.SecretsStub = nil
	if fake.secretsReturnsOnCall == nil {
		fake.secretsReturnsOnCall = make(map[int]struct {
			result1 v1core.SecretInterface
		})
	}
	fake.secretsReturnsOnCall[i] = struct {
		result1 v1core.SecretInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Services(namespace string) v1core.ServiceInterface {
	fake.servicesMutex.Lock()
	ret, specificReturn := fake.servicesReturnsOnCall[len(fake.servicesArgsForCall)]
	fake.servicesArgsForCall = append(fake.servicesArgsForCall, struct {
		namespace string
	}{namespace})
	fake.recordInvocation("Services", []interface{}{namespace})
	fake.servicesMutex.Unlock()
	if fake.ServicesStub != nil {
		return fake.ServicesStub(namespace)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.servicesReturns.result1
}

func (fake *FakeK8sCoreV1) ServicesCallCount() int {
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	return len(fake.servicesArgsForCall)
}

func (fake *FakeK8sCoreV1) ServicesArgsForCall(i int) string {
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	return fake.servicesArgsForCall[i].namespace
}

func (fake *FakeK8sCoreV1) ServicesReturns(result1 v1core.ServiceInterface) {
	fake.ServicesStub = nil
	fake.servicesReturns = struct {
		result1 v1core.ServiceInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ServicesReturnsOnCall(i int, result1 v1core.ServiceInterface) {
	fake.ServicesStub = nil
	if fake.servicesReturnsOnCall == nil {
		fake.servicesReturnsOnCall = make(map[int]struct {
			result1 v1core.ServiceInterface
		})
	}
	fake.servicesReturnsOnCall[i] = struct {
		result1 v1core.ServiceInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ServiceAccounts(namespace string) v1core.ServiceAccountInterface {
	fake.serviceAccountsMutex.Lock()
	ret, specificReturn := fake.serviceAccountsReturnsOnCall[len(fake.serviceAccountsArgsForCall)]
	fake.serviceAccountsArgsForCall = append(fake.serviceAccountsArgsForCall, struct {
		namespace string
	}{namespace})
	fake.recordInvocation("ServiceAccounts", []interface{}{namespace})
	fake.serviceAccountsMutex.Unlock()
	if fake.ServiceAccountsStub != nil {
		return fake.ServiceAccountsStub(namespace)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.serviceAccountsReturns.result1
}

func (fake *FakeK8sCoreV1) ServiceAccountsCallCount() int {
	fake.serviceAccountsMutex.RLock()
	defer fake.serviceAccountsMutex.RUnlock()
	return len(fake.serviceAccountsArgsForCall)
}

func (fake *FakeK8sCoreV1) ServiceAccountsArgsForCall(i int) string {
	fake.serviceAccountsMutex.RLock()
	defer fake.serviceAccountsMutex.RUnlock()
	return fake.serviceAccountsArgsForCall[i].namespace
}

func (fake *FakeK8sCoreV1) ServiceAccountsReturns(result1 v1core.ServiceAccountInterface) {
	fake.ServiceAccountsStub = nil
	fake.serviceAccountsReturns = struct {
		result1 v1core.ServiceAccountInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ServiceAccountsReturnsOnCall(i int, result1 v1core.ServiceAccountInterface) {
	fake.ServiceAccountsStub = nil
	if fake.serviceAccountsReturnsOnCall == nil {
		fake.serviceAccountsReturnsOnCall = make(map[int]struct {
			result1 v1core.ServiceAccountInterface
		})
	}
	fake.serviceAccountsReturnsOnCall[i] = struct {
		result1 v1core.ServiceAccountInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.rESTClientMutex.RLock()
	defer fake.rESTClientMutex.RUnlock()
	fake.componentStatusesMutex.RLock()
	defer fake.componentStatusesMutex.RUnlock()
	fake.configMapsMutex.RLock()
	defer fake.configMapsMutex.RUnlock()
	fake.endpointsMutex.RLock()
	defer fake.endpointsMutex.RUnlock()
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	fake.limitRangesMutex.RLock()
	defer fake.limitRangesMutex.RUnlock()
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	fake.nodesMutex.RLock()
	defer fake.nodesMutex.RUnlock()
	fake.persistentVolumesMutex.RLock()
	defer fake.persistentVolumesMutex.RUnlock()
	fake.persistentVolumeClaimsMutex.RLock()
	defer fake.persistentVolumeClaimsMutex.RUnlock()
	fake.podsMutex.RLock()
	defer fake.podsMutex.RUnlock()
	fake.podTemplatesMutex.RLock()
	defer fake.podTemplatesMutex.RUnlock()
	fake.replicationControllersMutex.RLock()
	defer fake.replicationControllersMutex.RUnlock()
	fake.resourceQuotasMutex.RLock()
	defer fake.resourceQuotasMutex.RUnlock()
	fake.secretsMutex.RLock()
	defer fake.secretsMutex.RUnlock()
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	fake.serviceAccountsMutex.RLock()
	defer fake.serviceAccountsMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeK8sCoreV1) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ k8sbroker.K8sCoreV1 = new(FakeK8sCoreV1)
