// Code generated by counterfeiter. DO NOT EDIT.
package k8sbroker_fake

import (
	sync "sync"

	k8sbroker "code.cloudfoundry.org/k8sbroker/k8sbroker"
	v1 "k8s.io/client-go/kubernetes/typed/core/v1"
	rest "k8s.io/client-go/rest"
)

type FakeK8sCoreV1 struct {
	ComponentStatusesStub        func() v1.ComponentStatusInterface
	componentStatusesMutex       sync.RWMutex
	componentStatusesArgsForCall []struct {
	}
	componentStatusesReturns struct {
		result1 v1.ComponentStatusInterface
	}
	componentStatusesReturnsOnCall map[int]struct {
		result1 v1.ComponentStatusInterface
	}
	ConfigMapsStub        func(string) v1.ConfigMapInterface
	configMapsMutex       sync.RWMutex
	configMapsArgsForCall []struct {
		arg1 string
	}
	configMapsReturns struct {
		result1 v1.ConfigMapInterface
	}
	configMapsReturnsOnCall map[int]struct {
		result1 v1.ConfigMapInterface
	}
	EndpointsStub        func(string) v1.EndpointsInterface
	endpointsMutex       sync.RWMutex
	endpointsArgsForCall []struct {
		arg1 string
	}
	endpointsReturns struct {
		result1 v1.EndpointsInterface
	}
	endpointsReturnsOnCall map[int]struct {
		result1 v1.EndpointsInterface
	}
	EventsStub        func(string) v1.EventInterface
	eventsMutex       sync.RWMutex
	eventsArgsForCall []struct {
		arg1 string
	}
	eventsReturns struct {
		result1 v1.EventInterface
	}
	eventsReturnsOnCall map[int]struct {
		result1 v1.EventInterface
	}
	LimitRangesStub        func(string) v1.LimitRangeInterface
	limitRangesMutex       sync.RWMutex
	limitRangesArgsForCall []struct {
		arg1 string
	}
	limitRangesReturns struct {
		result1 v1.LimitRangeInterface
	}
	limitRangesReturnsOnCall map[int]struct {
		result1 v1.LimitRangeInterface
	}
	NamespacesStub        func() v1.NamespaceInterface
	namespacesMutex       sync.RWMutex
	namespacesArgsForCall []struct {
	}
	namespacesReturns struct {
		result1 v1.NamespaceInterface
	}
	namespacesReturnsOnCall map[int]struct {
		result1 v1.NamespaceInterface
	}
	NodesStub        func() v1.NodeInterface
	nodesMutex       sync.RWMutex
	nodesArgsForCall []struct {
	}
	nodesReturns struct {
		result1 v1.NodeInterface
	}
	nodesReturnsOnCall map[int]struct {
		result1 v1.NodeInterface
	}
	PersistentVolumeClaimsStub        func(string) v1.PersistentVolumeClaimInterface
	persistentVolumeClaimsMutex       sync.RWMutex
	persistentVolumeClaimsArgsForCall []struct {
		arg1 string
	}
	persistentVolumeClaimsReturns struct {
		result1 v1.PersistentVolumeClaimInterface
	}
	persistentVolumeClaimsReturnsOnCall map[int]struct {
		result1 v1.PersistentVolumeClaimInterface
	}
	PersistentVolumesStub        func() v1.PersistentVolumeInterface
	persistentVolumesMutex       sync.RWMutex
	persistentVolumesArgsForCall []struct {
	}
	persistentVolumesReturns struct {
		result1 v1.PersistentVolumeInterface
	}
	persistentVolumesReturnsOnCall map[int]struct {
		result1 v1.PersistentVolumeInterface
	}
	PodTemplatesStub        func(string) v1.PodTemplateInterface
	podTemplatesMutex       sync.RWMutex
	podTemplatesArgsForCall []struct {
		arg1 string
	}
	podTemplatesReturns struct {
		result1 v1.PodTemplateInterface
	}
	podTemplatesReturnsOnCall map[int]struct {
		result1 v1.PodTemplateInterface
	}
	PodsStub        func(string) v1.PodInterface
	podsMutex       sync.RWMutex
	podsArgsForCall []struct {
		arg1 string
	}
	podsReturns struct {
		result1 v1.PodInterface
	}
	podsReturnsOnCall map[int]struct {
		result1 v1.PodInterface
	}
	RESTClientStub        func() rest.Interface
	rESTClientMutex       sync.RWMutex
	rESTClientArgsForCall []struct {
	}
	rESTClientReturns struct {
		result1 rest.Interface
	}
	rESTClientReturnsOnCall map[int]struct {
		result1 rest.Interface
	}
	ReplicationControllersStub        func(string) v1.ReplicationControllerInterface
	replicationControllersMutex       sync.RWMutex
	replicationControllersArgsForCall []struct {
		arg1 string
	}
	replicationControllersReturns struct {
		result1 v1.ReplicationControllerInterface
	}
	replicationControllersReturnsOnCall map[int]struct {
		result1 v1.ReplicationControllerInterface
	}
	ResourceQuotasStub        func(string) v1.ResourceQuotaInterface
	resourceQuotasMutex       sync.RWMutex
	resourceQuotasArgsForCall []struct {
		arg1 string
	}
	resourceQuotasReturns struct {
		result1 v1.ResourceQuotaInterface
	}
	resourceQuotasReturnsOnCall map[int]struct {
		result1 v1.ResourceQuotaInterface
	}
	SecretsStub        func(string) v1.SecretInterface
	secretsMutex       sync.RWMutex
	secretsArgsForCall []struct {
		arg1 string
	}
	secretsReturns struct {
		result1 v1.SecretInterface
	}
	secretsReturnsOnCall map[int]struct {
		result1 v1.SecretInterface
	}
	ServiceAccountsStub        func(string) v1.ServiceAccountInterface
	serviceAccountsMutex       sync.RWMutex
	serviceAccountsArgsForCall []struct {
		arg1 string
	}
	serviceAccountsReturns struct {
		result1 v1.ServiceAccountInterface
	}
	serviceAccountsReturnsOnCall map[int]struct {
		result1 v1.ServiceAccountInterface
	}
	ServicesStub        func(string) v1.ServiceInterface
	servicesMutex       sync.RWMutex
	servicesArgsForCall []struct {
		arg1 string
	}
	servicesReturns struct {
		result1 v1.ServiceInterface
	}
	servicesReturnsOnCall map[int]struct {
		result1 v1.ServiceInterface
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeK8sCoreV1) ComponentStatuses() v1.ComponentStatusInterface {
	fake.componentStatusesMutex.Lock()
	ret, specificReturn := fake.componentStatusesReturnsOnCall[len(fake.componentStatusesArgsForCall)]
	fake.componentStatusesArgsForCall = append(fake.componentStatusesArgsForCall, struct {
	}{})
	fake.recordInvocation("ComponentStatuses", []interface{}{})
	fake.componentStatusesMutex.Unlock()
	if fake.ComponentStatusesStub != nil {
		return fake.ComponentStatusesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.componentStatusesReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) ComponentStatusesCallCount() int {
	fake.componentStatusesMutex.RLock()
	defer fake.componentStatusesMutex.RUnlock()
	return len(fake.componentStatusesArgsForCall)
}

func (fake *FakeK8sCoreV1) ComponentStatusesCalls(stub func() v1.ComponentStatusInterface) {
	fake.componentStatusesMutex.Lock()
	defer fake.componentStatusesMutex.Unlock()
	fake.ComponentStatusesStub = stub
}

func (fake *FakeK8sCoreV1) ComponentStatusesReturns(result1 v1.ComponentStatusInterface) {
	fake.componentStatusesMutex.Lock()
	defer fake.componentStatusesMutex.Unlock()
	fake.ComponentStatusesStub = nil
	fake.componentStatusesReturns = struct {
		result1 v1.ComponentStatusInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ComponentStatusesReturnsOnCall(i int, result1 v1.ComponentStatusInterface) {
	fake.componentStatusesMutex.Lock()
	defer fake.componentStatusesMutex.Unlock()
	fake.ComponentStatusesStub = nil
	if fake.componentStatusesReturnsOnCall == nil {
		fake.componentStatusesReturnsOnCall = make(map[int]struct {
			result1 v1.ComponentStatusInterface
		})
	}
	fake.componentStatusesReturnsOnCall[i] = struct {
		result1 v1.ComponentStatusInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ConfigMaps(arg1 string) v1.ConfigMapInterface {
	fake.configMapsMutex.Lock()
	ret, specificReturn := fake.configMapsReturnsOnCall[len(fake.configMapsArgsForCall)]
	fake.configMapsArgsForCall = append(fake.configMapsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ConfigMaps", []interface{}{arg1})
	fake.configMapsMutex.Unlock()
	if fake.ConfigMapsStub != nil {
		return fake.ConfigMapsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.configMapsReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) ConfigMapsCallCount() int {
	fake.configMapsMutex.RLock()
	defer fake.configMapsMutex.RUnlock()
	return len(fake.configMapsArgsForCall)
}

func (fake *FakeK8sCoreV1) ConfigMapsCalls(stub func(string) v1.ConfigMapInterface) {
	fake.configMapsMutex.Lock()
	defer fake.configMapsMutex.Unlock()
	fake.ConfigMapsStub = stub
}

func (fake *FakeK8sCoreV1) ConfigMapsArgsForCall(i int) string {
	fake.configMapsMutex.RLock()
	defer fake.configMapsMutex.RUnlock()
	argsForCall := fake.configMapsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeK8sCoreV1) ConfigMapsReturns(result1 v1.ConfigMapInterface) {
	fake.configMapsMutex.Lock()
	defer fake.configMapsMutex.Unlock()
	fake.ConfigMapsStub = nil
	fake.configMapsReturns = struct {
		result1 v1.ConfigMapInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ConfigMapsReturnsOnCall(i int, result1 v1.ConfigMapInterface) {
	fake.configMapsMutex.Lock()
	defer fake.configMapsMutex.Unlock()
	fake.ConfigMapsStub = nil
	if fake.configMapsReturnsOnCall == nil {
		fake.configMapsReturnsOnCall = make(map[int]struct {
			result1 v1.ConfigMapInterface
		})
	}
	fake.configMapsReturnsOnCall[i] = struct {
		result1 v1.ConfigMapInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Endpoints(arg1 string) v1.EndpointsInterface {
	fake.endpointsMutex.Lock()
	ret, specificReturn := fake.endpointsReturnsOnCall[len(fake.endpointsArgsForCall)]
	fake.endpointsArgsForCall = append(fake.endpointsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Endpoints", []interface{}{arg1})
	fake.endpointsMutex.Unlock()
	if fake.EndpointsStub != nil {
		return fake.EndpointsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.endpointsReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) EndpointsCallCount() int {
	fake.endpointsMutex.RLock()
	defer fake.endpointsMutex.RUnlock()
	return len(fake.endpointsArgsForCall)
}

func (fake *FakeK8sCoreV1) EndpointsCalls(stub func(string) v1.EndpointsInterface) {
	fake.endpointsMutex.Lock()
	defer fake.endpointsMutex.Unlock()
	fake.EndpointsStub = stub
}

func (fake *FakeK8sCoreV1) EndpointsArgsForCall(i int) string {
	fake.endpointsMutex.RLock()
	defer fake.endpointsMutex.RUnlock()
	argsForCall := fake.endpointsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeK8sCoreV1) EndpointsReturns(result1 v1.EndpointsInterface) {
	fake.endpointsMutex.Lock()
	defer fake.endpointsMutex.Unlock()
	fake.EndpointsStub = nil
	fake.endpointsReturns = struct {
		result1 v1.EndpointsInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) EndpointsReturnsOnCall(i int, result1 v1.EndpointsInterface) {
	fake.endpointsMutex.Lock()
	defer fake.endpointsMutex.Unlock()
	fake.EndpointsStub = nil
	if fake.endpointsReturnsOnCall == nil {
		fake.endpointsReturnsOnCall = make(map[int]struct {
			result1 v1.EndpointsInterface
		})
	}
	fake.endpointsReturnsOnCall[i] = struct {
		result1 v1.EndpointsInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Events(arg1 string) v1.EventInterface {
	fake.eventsMutex.Lock()
	ret, specificReturn := fake.eventsReturnsOnCall[len(fake.eventsArgsForCall)]
	fake.eventsArgsForCall = append(fake.eventsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Events", []interface{}{arg1})
	fake.eventsMutex.Unlock()
	if fake.EventsStub != nil {
		return fake.EventsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.eventsReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) EventsCallCount() int {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return len(fake.eventsArgsForCall)
}

func (fake *FakeK8sCoreV1) EventsCalls(stub func(string) v1.EventInterface) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = stub
}

func (fake *FakeK8sCoreV1) EventsArgsForCall(i int) string {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	argsForCall := fake.eventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeK8sCoreV1) EventsReturns(result1 v1.EventInterface) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	fake.eventsReturns = struct {
		result1 v1.EventInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) EventsReturnsOnCall(i int, result1 v1.EventInterface) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	if fake.eventsReturnsOnCall == nil {
		fake.eventsReturnsOnCall = make(map[int]struct {
			result1 v1.EventInterface
		})
	}
	fake.eventsReturnsOnCall[i] = struct {
		result1 v1.EventInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) LimitRanges(arg1 string) v1.LimitRangeInterface {
	fake.limitRangesMutex.Lock()
	ret, specificReturn := fake.limitRangesReturnsOnCall[len(fake.limitRangesArgsForCall)]
	fake.limitRangesArgsForCall = append(fake.limitRangesArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("LimitRanges", []interface{}{arg1})
	fake.limitRangesMutex.Unlock()
	if fake.LimitRangesStub != nil {
		return fake.LimitRangesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.limitRangesReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) LimitRangesCallCount() int {
	fake.limitRangesMutex.RLock()
	defer fake.limitRangesMutex.RUnlock()
	return len(fake.limitRangesArgsForCall)
}

func (fake *FakeK8sCoreV1) LimitRangesCalls(stub func(string) v1.LimitRangeInterface) {
	fake.limitRangesMutex.Lock()
	defer fake.limitRangesMutex.Unlock()
	fake.LimitRangesStub = stub
}

func (fake *FakeK8sCoreV1) LimitRangesArgsForCall(i int) string {
	fake.limitRangesMutex.RLock()
	defer fake.limitRangesMutex.RUnlock()
	argsForCall := fake.limitRangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeK8sCoreV1) LimitRangesReturns(result1 v1.LimitRangeInterface) {
	fake.limitRangesMutex.Lock()
	defer fake.limitRangesMutex.Unlock()
	fake.LimitRangesStub = nil
	fake.limitRangesReturns = struct {
		result1 v1.LimitRangeInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) LimitRangesReturnsOnCall(i int, result1 v1.LimitRangeInterface) {
	fake.limitRangesMutex.Lock()
	defer fake.limitRangesMutex.Unlock()
	fake.LimitRangesStub = nil
	if fake.limitRangesReturnsOnCall == nil {
		fake.limitRangesReturnsOnCall = make(map[int]struct {
			result1 v1.LimitRangeInterface
		})
	}
	fake.limitRangesReturnsOnCall[i] = struct {
		result1 v1.LimitRangeInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Namespaces() v1.NamespaceInterface {
	fake.namespacesMutex.Lock()
	ret, specificReturn := fake.namespacesReturnsOnCall[len(fake.namespacesArgsForCall)]
	fake.namespacesArgsForCall = append(fake.namespacesArgsForCall, struct {
	}{})
	fake.recordInvocation("Namespaces", []interface{}{})
	fake.namespacesMutex.Unlock()
	if fake.NamespacesStub != nil {
		return fake.NamespacesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.namespacesReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) NamespacesCallCount() int {
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	return len(fake.namespacesArgsForCall)
}

func (fake *FakeK8sCoreV1) NamespacesCalls(stub func() v1.NamespaceInterface) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = stub
}

func (fake *FakeK8sCoreV1) NamespacesReturns(result1 v1.NamespaceInterface) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = nil
	fake.namespacesReturns = struct {
		result1 v1.NamespaceInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) NamespacesReturnsOnCall(i int, result1 v1.NamespaceInterface) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = nil
	if fake.namespacesReturnsOnCall == nil {
		fake.namespacesReturnsOnCall = make(map[int]struct {
			result1 v1.NamespaceInterface
		})
	}
	fake.namespacesReturnsOnCall[i] = struct {
		result1 v1.NamespaceInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Nodes() v1.NodeInterface {
	fake.nodesMutex.Lock()
	ret, specificReturn := fake.nodesReturnsOnCall[len(fake.nodesArgsForCall)]
	fake.nodesArgsForCall = append(fake.nodesArgsForCall, struct {
	}{})
	fake.recordInvocation("Nodes", []interface{}{})
	fake.nodesMutex.Unlock()
	if fake.NodesStub != nil {
		return fake.NodesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nodesReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) NodesCallCount() int {
	fake.nodesMutex.RLock()
	defer fake.nodesMutex.RUnlock()
	return len(fake.nodesArgsForCall)
}

func (fake *FakeK8sCoreV1) NodesCalls(stub func() v1.NodeInterface) {
	fake.nodesMutex.Lock()
	defer fake.nodesMutex.Unlock()
	fake.NodesStub = stub
}

func (fake *FakeK8sCoreV1) NodesReturns(result1 v1.NodeInterface) {
	fake.nodesMutex.Lock()
	defer fake.nodesMutex.Unlock()
	fake.NodesStub = nil
	fake.nodesReturns = struct {
		result1 v1.NodeInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) NodesReturnsOnCall(i int, result1 v1.NodeInterface) {
	fake.nodesMutex.Lock()
	defer fake.nodesMutex.Unlock()
	fake.NodesStub = nil
	if fake.nodesReturnsOnCall == nil {
		fake.nodesReturnsOnCall = make(map[int]struct {
			result1 v1.NodeInterface
		})
	}
	fake.nodesReturnsOnCall[i] = struct {
		result1 v1.NodeInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) PersistentVolumeClaims(arg1 string) v1.PersistentVolumeClaimInterface {
	fake.persistentVolumeClaimsMutex.Lock()
	ret, specificReturn := fake.persistentVolumeClaimsReturnsOnCall[len(fake.persistentVolumeClaimsArgsForCall)]
	fake.persistentVolumeClaimsArgsForCall = append(fake.persistentVolumeClaimsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("PersistentVolumeClaims", []interface{}{arg1})
	fake.persistentVolumeClaimsMutex.Unlock()
	if fake.PersistentVolumeClaimsStub != nil {
		return fake.PersistentVolumeClaimsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.persistentVolumeClaimsReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) PersistentVolumeClaimsCallCount() int {
	fake.persistentVolumeClaimsMutex.RLock()
	defer fake.persistentVolumeClaimsMutex.RUnlock()
	return len(fake.persistentVolumeClaimsArgsForCall)
}

func (fake *FakeK8sCoreV1) PersistentVolumeClaimsCalls(stub func(string) v1.PersistentVolumeClaimInterface) {
	fake.persistentVolumeClaimsMutex.Lock()
	defer fake.persistentVolumeClaimsMutex.Unlock()
	fake.PersistentVolumeClaimsStub = stub
}

func (fake *FakeK8sCoreV1) PersistentVolumeClaimsArgsForCall(i int) string {
	fake.persistentVolumeClaimsMutex.RLock()
	defer fake.persistentVolumeClaimsMutex.RUnlock()
	argsForCall := fake.persistentVolumeClaimsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeK8sCoreV1) PersistentVolumeClaimsReturns(result1 v1.PersistentVolumeClaimInterface) {
	fake.persistentVolumeClaimsMutex.Lock()
	defer fake.persistentVolumeClaimsMutex.Unlock()
	fake.PersistentVolumeClaimsStub = nil
	fake.persistentVolumeClaimsReturns = struct {
		result1 v1.PersistentVolumeClaimInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) PersistentVolumeClaimsReturnsOnCall(i int, result1 v1.PersistentVolumeClaimInterface) {
	fake.persistentVolumeClaimsMutex.Lock()
	defer fake.persistentVolumeClaimsMutex.Unlock()
	fake.PersistentVolumeClaimsStub = nil
	if fake.persistentVolumeClaimsReturnsOnCall == nil {
		fake.persistentVolumeClaimsReturnsOnCall = make(map[int]struct {
			result1 v1.PersistentVolumeClaimInterface
		})
	}
	fake.persistentVolumeClaimsReturnsOnCall[i] = struct {
		result1 v1.PersistentVolumeClaimInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) PersistentVolumes() v1.PersistentVolumeInterface {
	fake.persistentVolumesMutex.Lock()
	ret, specificReturn := fake.persistentVolumesReturnsOnCall[len(fake.persistentVolumesArgsForCall)]
	fake.persistentVolumesArgsForCall = append(fake.persistentVolumesArgsForCall, struct {
	}{})
	fake.recordInvocation("PersistentVolumes", []interface{}{})
	fake.persistentVolumesMutex.Unlock()
	if fake.PersistentVolumesStub != nil {
		return fake.PersistentVolumesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.persistentVolumesReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) PersistentVolumesCallCount() int {
	fake.persistentVolumesMutex.RLock()
	defer fake.persistentVolumesMutex.RUnlock()
	return len(fake.persistentVolumesArgsForCall)
}

func (fake *FakeK8sCoreV1) PersistentVolumesCalls(stub func() v1.PersistentVolumeInterface) {
	fake.persistentVolumesMutex.Lock()
	defer fake.persistentVolumesMutex.Unlock()
	fake.PersistentVolumesStub = stub
}

func (fake *FakeK8sCoreV1) PersistentVolumesReturns(result1 v1.PersistentVolumeInterface) {
	fake.persistentVolumesMutex.Lock()
	defer fake.persistentVolumesMutex.Unlock()
	fake.PersistentVolumesStub = nil
	fake.persistentVolumesReturns = struct {
		result1 v1.PersistentVolumeInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) PersistentVolumesReturnsOnCall(i int, result1 v1.PersistentVolumeInterface) {
	fake.persistentVolumesMutex.Lock()
	defer fake.persistentVolumesMutex.Unlock()
	fake.PersistentVolumesStub = nil
	if fake.persistentVolumesReturnsOnCall == nil {
		fake.persistentVolumesReturnsOnCall = make(map[int]struct {
			result1 v1.PersistentVolumeInterface
		})
	}
	fake.persistentVolumesReturnsOnCall[i] = struct {
		result1 v1.PersistentVolumeInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) PodTemplates(arg1 string) v1.PodTemplateInterface {
	fake.podTemplatesMutex.Lock()
	ret, specificReturn := fake.podTemplatesReturnsOnCall[len(fake.podTemplatesArgsForCall)]
	fake.podTemplatesArgsForCall = append(fake.podTemplatesArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("PodTemplates", []interface{}{arg1})
	fake.podTemplatesMutex.Unlock()
	if fake.PodTemplatesStub != nil {
		return fake.PodTemplatesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.podTemplatesReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) PodTemplatesCallCount() int {
	fake.podTemplatesMutex.RLock()
	defer fake.podTemplatesMutex.RUnlock()
	return len(fake.podTemplatesArgsForCall)
}

func (fake *FakeK8sCoreV1) PodTemplatesCalls(stub func(string) v1.PodTemplateInterface) {
	fake.podTemplatesMutex.Lock()
	defer fake.podTemplatesMutex.Unlock()
	fake.PodTemplatesStub = stub
}

func (fake *FakeK8sCoreV1) PodTemplatesArgsForCall(i int) string {
	fake.podTemplatesMutex.RLock()
	defer fake.podTemplatesMutex.RUnlock()
	argsForCall := fake.podTemplatesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeK8sCoreV1) PodTemplatesReturns(result1 v1.PodTemplateInterface) {
	fake.podTemplatesMutex.Lock()
	defer fake.podTemplatesMutex.Unlock()
	fake.PodTemplatesStub = nil
	fake.podTemplatesReturns = struct {
		result1 v1.PodTemplateInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) PodTemplatesReturnsOnCall(i int, result1 v1.PodTemplateInterface) {
	fake.podTemplatesMutex.Lock()
	defer fake.podTemplatesMutex.Unlock()
	fake.PodTemplatesStub = nil
	if fake.podTemplatesReturnsOnCall == nil {
		fake.podTemplatesReturnsOnCall = make(map[int]struct {
			result1 v1.PodTemplateInterface
		})
	}
	fake.podTemplatesReturnsOnCall[i] = struct {
		result1 v1.PodTemplateInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Pods(arg1 string) v1.PodInterface {
	fake.podsMutex.Lock()
	ret, specificReturn := fake.podsReturnsOnCall[len(fake.podsArgsForCall)]
	fake.podsArgsForCall = append(fake.podsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Pods", []interface{}{arg1})
	fake.podsMutex.Unlock()
	if fake.PodsStub != nil {
		return fake.PodsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.podsReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) PodsCallCount() int {
	fake.podsMutex.RLock()
	defer fake.podsMutex.RUnlock()
	return len(fake.podsArgsForCall)
}

func (fake *FakeK8sCoreV1) PodsCalls(stub func(string) v1.PodInterface) {
	fake.podsMutex.Lock()
	defer fake.podsMutex.Unlock()
	fake.PodsStub = stub
}

func (fake *FakeK8sCoreV1) PodsArgsForCall(i int) string {
	fake.podsMutex.RLock()
	defer fake.podsMutex.RUnlock()
	argsForCall := fake.podsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeK8sCoreV1) PodsReturns(result1 v1.PodInterface) {
	fake.podsMutex.Lock()
	defer fake.podsMutex.Unlock()
	fake.PodsStub = nil
	fake.podsReturns = struct {
		result1 v1.PodInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) PodsReturnsOnCall(i int, result1 v1.PodInterface) {
	fake.podsMutex.Lock()
	defer fake.podsMutex.Unlock()
	fake.PodsStub = nil
	if fake.podsReturnsOnCall == nil {
		fake.podsReturnsOnCall = make(map[int]struct {
			result1 v1.PodInterface
		})
	}
	fake.podsReturnsOnCall[i] = struct {
		result1 v1.PodInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) RESTClient() rest.Interface {
	fake.rESTClientMutex.Lock()
	ret, specificReturn := fake.rESTClientReturnsOnCall[len(fake.rESTClientArgsForCall)]
	fake.rESTClientArgsForCall = append(fake.rESTClientArgsForCall, struct {
	}{})
	fake.recordInvocation("RESTClient", []interface{}{})
	fake.rESTClientMutex.Unlock()
	if fake.RESTClientStub != nil {
		return fake.RESTClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.rESTClientReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) RESTClientCallCount() int {
	fake.rESTClientMutex.RLock()
	defer fake.rESTClientMutex.RUnlock()
	return len(fake.rESTClientArgsForCall)
}

func (fake *FakeK8sCoreV1) RESTClientCalls(stub func() rest.Interface) {
	fake.rESTClientMutex.Lock()
	defer fake.rESTClientMutex.Unlock()
	fake.RESTClientStub = stub
}

func (fake *FakeK8sCoreV1) RESTClientReturns(result1 rest.Interface) {
	fake.rESTClientMutex.Lock()
	defer fake.rESTClientMutex.Unlock()
	fake.RESTClientStub = nil
	fake.rESTClientReturns = struct {
		result1 rest.Interface
	}{result1}
}

func (fake *FakeK8sCoreV1) RESTClientReturnsOnCall(i int, result1 rest.Interface) {
	fake.rESTClientMutex.Lock()
	defer fake.rESTClientMutex.Unlock()
	fake.RESTClientStub = nil
	if fake.rESTClientReturnsOnCall == nil {
		fake.rESTClientReturnsOnCall = make(map[int]struct {
			result1 rest.Interface
		})
	}
	fake.rESTClientReturnsOnCall[i] = struct {
		result1 rest.Interface
	}{result1}
}

func (fake *FakeK8sCoreV1) ReplicationControllers(arg1 string) v1.ReplicationControllerInterface {
	fake.replicationControllersMutex.Lock()
	ret, specificReturn := fake.replicationControllersReturnsOnCall[len(fake.replicationControllersArgsForCall)]
	fake.replicationControllersArgsForCall = append(fake.replicationControllersArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ReplicationControllers", []interface{}{arg1})
	fake.replicationControllersMutex.Unlock()
	if fake.ReplicationControllersStub != nil {
		return fake.ReplicationControllersStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.replicationControllersReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) ReplicationControllersCallCount() int {
	fake.replicationControllersMutex.RLock()
	defer fake.replicationControllersMutex.RUnlock()
	return len(fake.replicationControllersArgsForCall)
}

func (fake *FakeK8sCoreV1) ReplicationControllersCalls(stub func(string) v1.ReplicationControllerInterface) {
	fake.replicationControllersMutex.Lock()
	defer fake.replicationControllersMutex.Unlock()
	fake.ReplicationControllersStub = stub
}

func (fake *FakeK8sCoreV1) ReplicationControllersArgsForCall(i int) string {
	fake.replicationControllersMutex.RLock()
	defer fake.replicationControllersMutex.RUnlock()
	argsForCall := fake.replicationControllersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeK8sCoreV1) ReplicationControllersReturns(result1 v1.ReplicationControllerInterface) {
	fake.replicationControllersMutex.Lock()
	defer fake.replicationControllersMutex.Unlock()
	fake.ReplicationControllersStub = nil
	fake.replicationControllersReturns = struct {
		result1 v1.ReplicationControllerInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ReplicationControllersReturnsOnCall(i int, result1 v1.ReplicationControllerInterface) {
	fake.replicationControllersMutex.Lock()
	defer fake.replicationControllersMutex.Unlock()
	fake.ReplicationControllersStub = nil
	if fake.replicationControllersReturnsOnCall == nil {
		fake.replicationControllersReturnsOnCall = make(map[int]struct {
			result1 v1.ReplicationControllerInterface
		})
	}
	fake.replicationControllersReturnsOnCall[i] = struct {
		result1 v1.ReplicationControllerInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ResourceQuotas(arg1 string) v1.ResourceQuotaInterface {
	fake.resourceQuotasMutex.Lock()
	ret, specificReturn := fake.resourceQuotasReturnsOnCall[len(fake.resourceQuotasArgsForCall)]
	fake.resourceQuotasArgsForCall = append(fake.resourceQuotasArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ResourceQuotas", []interface{}{arg1})
	fake.resourceQuotasMutex.Unlock()
	if fake.ResourceQuotasStub != nil {
		return fake.ResourceQuotasStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resourceQuotasReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) ResourceQuotasCallCount() int {
	fake.resourceQuotasMutex.RLock()
	defer fake.resourceQuotasMutex.RUnlock()
	return len(fake.resourceQuotasArgsForCall)
}

func (fake *FakeK8sCoreV1) ResourceQuotasCalls(stub func(string) v1.ResourceQuotaInterface) {
	fake.resourceQuotasMutex.Lock()
	defer fake.resourceQuotasMutex.Unlock()
	fake.ResourceQuotasStub = stub
}

func (fake *FakeK8sCoreV1) ResourceQuotasArgsForCall(i int) string {
	fake.resourceQuotasMutex.RLock()
	defer fake.resourceQuotasMutex.RUnlock()
	argsForCall := fake.resourceQuotasArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeK8sCoreV1) ResourceQuotasReturns(result1 v1.ResourceQuotaInterface) {
	fake.resourceQuotasMutex.Lock()
	defer fake.resourceQuotasMutex.Unlock()
	fake.ResourceQuotasStub = nil
	fake.resourceQuotasReturns = struct {
		result1 v1.ResourceQuotaInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ResourceQuotasReturnsOnCall(i int, result1 v1.ResourceQuotaInterface) {
	fake.resourceQuotasMutex.Lock()
	defer fake.resourceQuotasMutex.Unlock()
	fake.ResourceQuotasStub = nil
	if fake.resourceQuotasReturnsOnCall == nil {
		fake.resourceQuotasReturnsOnCall = make(map[int]struct {
			result1 v1.ResourceQuotaInterface
		})
	}
	fake.resourceQuotasReturnsOnCall[i] = struct {
		result1 v1.ResourceQuotaInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Secrets(arg1 string) v1.SecretInterface {
	fake.secretsMutex.Lock()
	ret, specificReturn := fake.secretsReturnsOnCall[len(fake.secretsArgsForCall)]
	fake.secretsArgsForCall = append(fake.secretsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Secrets", []interface{}{arg1})
	fake.secretsMutex.Unlock()
	if fake.SecretsStub != nil {
		return fake.SecretsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.secretsReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) SecretsCallCount() int {
	fake.secretsMutex.RLock()
	defer fake.secretsMutex.RUnlock()
	return len(fake.secretsArgsForCall)
}

func (fake *FakeK8sCoreV1) SecretsCalls(stub func(string) v1.SecretInterface) {
	fake.secretsMutex.Lock()
	defer fake.secretsMutex.Unlock()
	fake.SecretsStub = stub
}

func (fake *FakeK8sCoreV1) SecretsArgsForCall(i int) string {
	fake.secretsMutex.RLock()
	defer fake.secretsMutex.RUnlock()
	argsForCall := fake.secretsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeK8sCoreV1) SecretsReturns(result1 v1.SecretInterface) {
	fake.secretsMutex.Lock()
	defer fake.secretsMutex.Unlock()
	fake.SecretsStub = nil
	fake.secretsReturns = struct {
		result1 v1.SecretInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) SecretsReturnsOnCall(i int, result1 v1.SecretInterface) {
	fake.secretsMutex.Lock()
	defer fake.secretsMutex.Unlock()
	fake.SecretsStub = nil
	if fake.secretsReturnsOnCall == nil {
		fake.secretsReturnsOnCall = make(map[int]struct {
			result1 v1.SecretInterface
		})
	}
	fake.secretsReturnsOnCall[i] = struct {
		result1 v1.SecretInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ServiceAccounts(arg1 string) v1.ServiceAccountInterface {
	fake.serviceAccountsMutex.Lock()
	ret, specificReturn := fake.serviceAccountsReturnsOnCall[len(fake.serviceAccountsArgsForCall)]
	fake.serviceAccountsArgsForCall = append(fake.serviceAccountsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ServiceAccounts", []interface{}{arg1})
	fake.serviceAccountsMutex.Unlock()
	if fake.ServiceAccountsStub != nil {
		return fake.ServiceAccountsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.serviceAccountsReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) ServiceAccountsCallCount() int {
	fake.serviceAccountsMutex.RLock()
	defer fake.serviceAccountsMutex.RUnlock()
	return len(fake.serviceAccountsArgsForCall)
}

func (fake *FakeK8sCoreV1) ServiceAccountsCalls(stub func(string) v1.ServiceAccountInterface) {
	fake.serviceAccountsMutex.Lock()
	defer fake.serviceAccountsMutex.Unlock()
	fake.ServiceAccountsStub = stub
}

func (fake *FakeK8sCoreV1) ServiceAccountsArgsForCall(i int) string {
	fake.serviceAccountsMutex.RLock()
	defer fake.serviceAccountsMutex.RUnlock()
	argsForCall := fake.serviceAccountsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeK8sCoreV1) ServiceAccountsReturns(result1 v1.ServiceAccountInterface) {
	fake.serviceAccountsMutex.Lock()
	defer fake.serviceAccountsMutex.Unlock()
	fake.ServiceAccountsStub = nil
	fake.serviceAccountsReturns = struct {
		result1 v1.ServiceAccountInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ServiceAccountsReturnsOnCall(i int, result1 v1.ServiceAccountInterface) {
	fake.serviceAccountsMutex.Lock()
	defer fake.serviceAccountsMutex.Unlock()
	fake.ServiceAccountsStub = nil
	if fake.serviceAccountsReturnsOnCall == nil {
		fake.serviceAccountsReturnsOnCall = make(map[int]struct {
			result1 v1.ServiceAccountInterface
		})
	}
	fake.serviceAccountsReturnsOnCall[i] = struct {
		result1 v1.ServiceAccountInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Services(arg1 string) v1.ServiceInterface {
	fake.servicesMutex.Lock()
	ret, specificReturn := fake.servicesReturnsOnCall[len(fake.servicesArgsForCall)]
	fake.servicesArgsForCall = append(fake.servicesArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Services", []interface{}{arg1})
	fake.servicesMutex.Unlock()
	if fake.ServicesStub != nil {
		return fake.ServicesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.servicesReturns
	return fakeReturns.result1
}

func (fake *FakeK8sCoreV1) ServicesCallCount() int {
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	return len(fake.servicesArgsForCall)
}

func (fake *FakeK8sCoreV1) ServicesCalls(stub func(string) v1.ServiceInterface) {
	fake.servicesMutex.Lock()
	defer fake.servicesMutex.Unlock()
	fake.ServicesStub = stub
}

func (fake *FakeK8sCoreV1) ServicesArgsForCall(i int) string {
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	argsForCall := fake.servicesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeK8sCoreV1) ServicesReturns(result1 v1.ServiceInterface) {
	fake.servicesMutex.Lock()
	defer fake.servicesMutex.Unlock()
	fake.ServicesStub = nil
	fake.servicesReturns = struct {
		result1 v1.ServiceInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) ServicesReturnsOnCall(i int, result1 v1.ServiceInterface) {
	fake.servicesMutex.Lock()
	defer fake.servicesMutex.Unlock()
	fake.ServicesStub = nil
	if fake.servicesReturnsOnCall == nil {
		fake.servicesReturnsOnCall = make(map[int]struct {
			result1 v1.ServiceInterface
		})
	}
	fake.servicesReturnsOnCall[i] = struct {
		result1 v1.ServiceInterface
	}{result1}
}

func (fake *FakeK8sCoreV1) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.componentStatusesMutex.RLock()
	defer fake.componentStatusesMutex.RUnlock()
	fake.configMapsMutex.RLock()
	defer fake.configMapsMutex.RUnlock()
	fake.endpointsMutex.RLock()
	defer fake.endpointsMutex.RUnlock()
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	fake.limitRangesMutex.RLock()
	defer fake.limitRangesMutex.RUnlock()
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	fake.nodesMutex.RLock()
	defer fake.nodesMutex.RUnlock()
	fake.persistentVolumeClaimsMutex.RLock()
	defer fake.persistentVolumeClaimsMutex.RUnlock()
	fake.persistentVolumesMutex.RLock()
	defer fake.persistentVolumesMutex.RUnlock()
	fake.podTemplatesMutex.RLock()
	defer fake.podTemplatesMutex.RUnlock()
	fake.podsMutex.RLock()
	defer fake.podsMutex.RUnlock()
	fake.rESTClientMutex.RLock()
	defer fake.rESTClientMutex.RUnlock()
	fake.replicationControllersMutex.RLock()
	defer fake.replicationControllersMutex.RUnlock()
	fake.resourceQuotasMutex.RLock()
	defer fake.resourceQuotasMutex.RUnlock()
	fake.secretsMutex.RLock()
	defer fake.secretsMutex.RUnlock()
	fake.serviceAccountsMutex.RLock()
	defer fake.serviceAccountsMutex.RUnlock()
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeK8sCoreV1) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ k8sbroker.K8sCoreV1 = new(FakeK8sCoreV1)
